#include <stdio.h>
#include <string.h>

// 220번줄로 이동하세요
void greetPrint()
{
	printf("\n\n안녕하세요 사랑합니다!\n\n");

}

int addMode(int a, int b)
{

	return a + b;
}





int main()
{
	//포인터에 대해서 알아보자
	int b;
	int* p; // 이런 형태가 있을때 * 이 달린 변수를 
	// 포인터 변수라고 한다.


//그렇다면 어떻게 활용을 하나

	int a = 10;
	// 이런식으로 포인터 변수에다가 a의 주솟값을 링커 해준것을 가져온다.
	p = &a;
	b = &a;
	printf_s("%p \n\n", p); // 00000091576FFB04 이 나온다.
	//printf_s("%p \n\n", b); // 경고가 뜨는데 내용은 포인터변수가 아닌곳에 주소를 넣었다.

	// 자 이번엔 배열포인터 봅시다.
	int* s[3] = { 1,2,3 };

	printf_s("%d\n\n", (s + 1)); // 주소값에 접근했다.

	printf_s("%d\n\n", *(s)); // s + 1 즉 4바이트씩 1칸 이동했다.		1
	printf_s("%d\n\n", *(s + 1)); // s + 1 즉 4바이트씩 1칸 이동했다.	2
	printf_s("%d\n\n", *(s + 2)); // s + 2 즉 4바이트씩 2칸 이동했다.	3


	printf_s("%d\n\n", s[0]); // 이렇게도 가능하다.
	printf_s("%d\n\n", s[1]);
	printf_s("%d\n\n", s[2]);

	// 즉 s + 1 은 마치 인덱스방식이다. 왜냐 s가 int 형으로 선언됨 -> 4바이트씩 


	//부호가 없는 긴 포인터 변수선언
	unsigned long long* pt = &a; // 포인터 변수 p에다가 a의 주소를 넣는다.
	//%u는 부호없는 
	printf_s("%20u\n", &pt); // 1  pt의 주소는 뭐냐?
	printf_s("%20u\n", pt); // 2	pt에는 a의주소가 담겨있어 출력	
	printf_s("%20u\n", *pt); // 3	pt참조 (내용확인) 하면 10이 나온다.
	printf_s("%20u\n", a); // 4     a = 10이 들어있다.
	printf_s("%20u\n", &a); // 5	a의 주소는 뭐냐?

	/*	3146774600
		3146774516			2번과 5번 값이 같다.
		10					*접근연산자 즉 3번은 4번과 같다.
		10
		3146774516*/






		////////////////////////////////////////////////////////////////////





			//포인터 -> 데이터의 변환과 보안에 유용하게 이용하기 위해서 사용한다.,
				// 포인터와 비슷하게 주소로 이루어진것 -> 배열

		// 포인터 변수를 저장할 수 있는 배열을 의미

		// 그니까 즉 배열 형태인데 배열의 각각의 요소에 주소값이 있는것을 의미한다.

	int arr[5] = { 1,2,3,4,5 };
	int* ptr = arr;
	printf_s("\n%d = %d =%d =%d\n", &arr[0], *(arr + 0), &ptr[0], ptr + 0);
	//                            arr[0] 주소가 뭐냐
	printf_s("%d = %d =%d =%d\n", &arr[1], *(arr + 1), &ptr[1], ptr + 1);
	//	접근 arr+1 2가 나온다.
	printf_s("%d = %d =%d =%d\n", &arr[2], *(arr + 2), &ptr[2], ptr + 2);
	//							ptr[2]의 주소가 뭐야
	printf_s("%d = %d =%d =%d\n", &arr[4], *(arr + 3), &ptr[3], ptr + 3);
	//								ptr + 3 는 주소가 나온다.
	printf_s("%d = %d =%d =%d\n", &arr[3], *(arr + 4), &ptr[4], ptr + 4);

	printf_s("%d\n", (arr + 1)); // 예도 주소가 나와요
	printf_s("%d\n", arr); // 예도 주소가 나와요



	// 배열 10개 만들고 짝수들은 0포함 해서 정상 출력 홀수는 0으로
	int numArray[10] = { 0,0,0,0,0,0,0,0,0,0 };

	int* myptr = &numArray;

	for (int i = 0; i < 10; ++i)
	{
		if (i % 2 == 0)
		{
			myptr[i] = i;
		}
		printf("\n%d\n", *(myptr + i));
	}


	/////////////////////////////////////////////////////////////////////


	//				10공간				10공간				10공간
	int arr1[] = { 0,1 }, arr2[] = { 2,3,4 }, arr3[] = { 5,6,7,8 };
	int* ac[10] = { arr1,arr2,arr3 }; // 배열 포인터 (포인터 배열과는 다르다.)
	//* ac[2]는 즉 2공간씩 자른다.		// 배열을 가리킬 수 있는 포인터를 의미
										// 포인터를 배열처럼 사용하기 위해서 배열 포인터를 정의하여 사용
	ac[0][1]; // arr[1]
	ac[1][2]; // arr[2]

	printf_s("\n\n");
	printf_s("\n%d\n", ac[0][0]);
	printf_s("\n%d\n", ac[0][1]);
	printf_s("\n%d\n", ac[1][0]);


	printf_s("\n\n");

	printf_s("\n%d\n", ac); // ac의 주소값이 출력이 된다.
	printf_s("\n%d\n", *ac); // ac의 값은 결국에 ac[0]는 대표주소를 갖고 있기 떄문에 주소가 나온다.
	printf_s("\n%d\n", **ac); // ac의 값에 값은 ac[0][0] 값인 0이 나온다!!
	printf_s("\n%d\n", *(*ac + 1)); // ac의 값에 값은 ac[0]의 주소에 한공간 넘어가서 
	// 예를들어 주소가 100 과 102가 있다면 101의 값을 전달받는것
	printf_s("\n%d\n", *(*ac + 8)); // [1][0]
	printf_s("\n%d\n", *(*ac + 9)); // [1][1]
	printf_s("\n%d\n", *(*ac + 10)); // [1][2]
	printf_s("\n%d\n", *(*ac + 20)); // [2][0]
	printf_s("\n%d\n", *(*ac + 21)); // [2][1]

	printf_s("\n%d\n", ac[2][1]);





	//문자열 5문장 포인터 배열에 저장후
	// 포인터 배열을 이용하여 문자열에서 대문자만 골라 출력하는 프로그램 작성


	char* myword[] =
	{
		{"Hello"},{"It is me"},{"Look out the Window"}
	};

	for (int i = 0; i < 3; ++i)
	{
		for (int j = 0; j < 18; ++j)
		{
			if (myword[i][j] >= 'A' && myword[i][j] <= 'Z')
			{
				printf_s("%c ", myword[i][j]);
			}

		}
	}





	///////////////////////////////////////////////////////////////////////



		// void 포인터
		// 비어있는 자료형에 주소값을

	int t = 10;
	void* vptr = &t;
	// 자료형을 정의하기가 애매할때 .
			// 인트도 받고 캐릭터도 받고 등등 할때

	//printf("%d\n", *vptr); // 안되는데 이유가 해석방식 정의가 않되서
					// 자료형이 없어서 2바이트냐 4바이트냐 플롯방식이냐 등 구별이 않되서



	// 즉, 주소값만 받는다.

	// 그렇다면... 어떻게 써...?
				// 형변환을 통해... 할수있다.

	printf_s("\n%d\n", *(int*)vptr);

	// 그러면 배열은여?
	int arr5[5] =
	{ 3, 5, 7, 9, 11 };

	void* arptr = &arr5;

	printf_s("%d\n", *(int*)arptr);
	printf_s("%d\n", *(((int*)arptr)+1)); // 형변환후 한공간 넘어가기

	// 결론 다시 특정 자료형의 변수로 변경한 다음 이용하자....





		/////////////////////////////////////////////////////////////////////

	// 함수 포인터? 
		// 한마디로 함수의 주소를 갖는 변수 이다.


	// 매개변수 없는 함수는 !!!!!!!!!!!

				// void (*fp)();

	// 맨위에다가 함수 greetPrint 라는 것을 생성하고 주소를 확인해보자.
	printf("내가만든 함수의 주소값 : %p\n", greetPrint);

	// 즉, 함수 포인터는 함수의 주소를 저장했다가 해당 주소의 함수를 호출하는 데 사용하는 포인터

	void(*fp)(); //반환값과 매개변수가 없는 함수 포인터 fp 선언
	fp = greetPrint; // fp에다가 greetPrint 함수의 주소값을 넣는다.
	
	greetPrint();
	fp(); // 함수 호출!
	// fp 포인터를 역참조하여 함수를 호출
	
	printf("내가만든 함수의 주소값 : %p\n", greetPrint);
	printf("내가만든 포인터 함수의 주소값 : %p\n\n", fp);

	// 즉 둘의 주소는 현재 같다.

	printf("내가만든 함수의 주소값 : %p\n", &greetPrint);
	printf("내가만든 포인터 함수의 자체 주소값 : %p\n\n", &fp);

	printf("2내가만든 함수의 주소값 : %p\n", *greetPrint);
	printf("2내가만든 포인터 함수의 자체 주소값 : %p\n", *fp);




	// 그렇다면 매개변수가 있는 함수는?

	int (*sfg)(int, int);

	sfg = &addMode; // addMode 주소값을 sfg에 저장했다.

	printf_s("\n%d\n",sfg(2, 4)); // 함수 호출과 동시 출력쓰


}
